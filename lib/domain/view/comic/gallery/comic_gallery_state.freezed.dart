// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'comic_gallery_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ComicGalleryStateTearOff {
  const _$ComicGalleryStateTearOff();

  Initial initial() {
    return const Initial();
  }

  SetButtonsVisibility setButtonsVisibility(
      {required Key key,
      required bool previousButtonVisible,
      required bool nextButtonVisible}) {
    return SetButtonsVisibility(
      key: key,
      previousButtonVisible: previousButtonVisible,
      nextButtonVisible: nextButtonVisible,
    );
  }

  NavigateToArchive navigateToArchive({required Key key}) {
    return NavigateToArchive(
      key: key,
    );
  }
}

/// @nodoc
const $ComicGalleryState = _$ComicGalleryStateTearOff();

/// @nodoc
mixin _$ComicGalleryState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)
        setButtonsVisibility,
    required TResult Function(Key key) navigateToArchive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(SetButtonsVisibility value) setButtonsVisibility,
    required TResult Function(NavigateToArchive value) navigateToArchive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComicGalleryStateCopyWith<$Res> {
  factory $ComicGalleryStateCopyWith(
          ComicGalleryState value, $Res Function(ComicGalleryState) then) =
      _$ComicGalleryStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ComicGalleryStateCopyWithImpl<$Res>
    implements $ComicGalleryStateCopyWith<$Res> {
  _$ComicGalleryStateCopyWithImpl(this._value, this._then);

  final ComicGalleryState _value;
  // ignore: unused_field
  final $Res Function(ComicGalleryState) _then;
}

/// @nodoc
abstract class $InitialCopyWith<$Res> {
  factory $InitialCopyWith(Initial value, $Res Function(Initial) then) =
      _$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialCopyWithImpl<$Res> extends _$ComicGalleryStateCopyWithImpl<$Res>
    implements $InitialCopyWith<$Res> {
  _$InitialCopyWithImpl(Initial _value, $Res Function(Initial) _then)
      : super(_value, (v) => _then(v as Initial));

  @override
  Initial get _value => super._value as Initial;
}

/// @nodoc

class _$Initial implements Initial {
  const _$Initial();

  @override
  String toString() {
    return 'ComicGalleryState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)
        setButtonsVisibility,
    required TResult Function(Key key) navigateToArchive,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(SetButtonsVisibility value) setButtonsVisibility,
    required TResult Function(NavigateToArchive value) navigateToArchive,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements ComicGalleryState {
  const factory Initial() = _$Initial;
}

/// @nodoc
abstract class $SetButtonsVisibilityCopyWith<$Res> {
  factory $SetButtonsVisibilityCopyWith(SetButtonsVisibility value,
          $Res Function(SetButtonsVisibility) then) =
      _$SetButtonsVisibilityCopyWithImpl<$Res>;
  $Res call({Key key, bool previousButtonVisible, bool nextButtonVisible});
}

/// @nodoc
class _$SetButtonsVisibilityCopyWithImpl<$Res>
    extends _$ComicGalleryStateCopyWithImpl<$Res>
    implements $SetButtonsVisibilityCopyWith<$Res> {
  _$SetButtonsVisibilityCopyWithImpl(
      SetButtonsVisibility _value, $Res Function(SetButtonsVisibility) _then)
      : super(_value, (v) => _then(v as SetButtonsVisibility));

  @override
  SetButtonsVisibility get _value => super._value as SetButtonsVisibility;

  @override
  $Res call({
    Object? key = freezed,
    Object? previousButtonVisible = freezed,
    Object? nextButtonVisible = freezed,
  }) {
    return _then(SetButtonsVisibility(
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as Key,
      previousButtonVisible: previousButtonVisible == freezed
          ? _value.previousButtonVisible
          : previousButtonVisible // ignore: cast_nullable_to_non_nullable
              as bool,
      nextButtonVisible: nextButtonVisible == freezed
          ? _value.nextButtonVisible
          : nextButtonVisible // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SetButtonsVisibility implements SetButtonsVisibility {
  const _$SetButtonsVisibility(
      {required this.key,
      required this.previousButtonVisible,
      required this.nextButtonVisible});

  @override
  final Key key;
  @override
  final bool previousButtonVisible;
  @override
  final bool nextButtonVisible;

  @override
  String toString() {
    return 'ComicGalleryState.setButtonsVisibility(key: $key, previousButtonVisible: $previousButtonVisible, nextButtonVisible: $nextButtonVisible)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetButtonsVisibility &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.previousButtonVisible, previousButtonVisible) ||
                other.previousButtonVisible == previousButtonVisible) &&
            (identical(other.nextButtonVisible, nextButtonVisible) ||
                other.nextButtonVisible == nextButtonVisible));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, key, previousButtonVisible, nextButtonVisible);

  @JsonKey(ignore: true)
  @override
  $SetButtonsVisibilityCopyWith<SetButtonsVisibility> get copyWith =>
      _$SetButtonsVisibilityCopyWithImpl<SetButtonsVisibility>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)
        setButtonsVisibility,
    required TResult Function(Key key) navigateToArchive,
  }) {
    return setButtonsVisibility(key, previousButtonVisible, nextButtonVisible);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
  }) {
    return setButtonsVisibility?.call(
        key, previousButtonVisible, nextButtonVisible);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
    required TResult orElse(),
  }) {
    if (setButtonsVisibility != null) {
      return setButtonsVisibility(
          key, previousButtonVisible, nextButtonVisible);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(SetButtonsVisibility value) setButtonsVisibility,
    required TResult Function(NavigateToArchive value) navigateToArchive,
  }) {
    return setButtonsVisibility(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
  }) {
    return setButtonsVisibility?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
    required TResult orElse(),
  }) {
    if (setButtonsVisibility != null) {
      return setButtonsVisibility(this);
    }
    return orElse();
  }
}

abstract class SetButtonsVisibility implements ComicGalleryState {
  const factory SetButtonsVisibility(
      {required Key key,
      required bool previousButtonVisible,
      required bool nextButtonVisible}) = _$SetButtonsVisibility;

  Key get key;
  bool get previousButtonVisible;
  bool get nextButtonVisible;
  @JsonKey(ignore: true)
  $SetButtonsVisibilityCopyWith<SetButtonsVisibility> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NavigateToArchiveCopyWith<$Res> {
  factory $NavigateToArchiveCopyWith(
          NavigateToArchive value, $Res Function(NavigateToArchive) then) =
      _$NavigateToArchiveCopyWithImpl<$Res>;
  $Res call({Key key});
}

/// @nodoc
class _$NavigateToArchiveCopyWithImpl<$Res>
    extends _$ComicGalleryStateCopyWithImpl<$Res>
    implements $NavigateToArchiveCopyWith<$Res> {
  _$NavigateToArchiveCopyWithImpl(
      NavigateToArchive _value, $Res Function(NavigateToArchive) _then)
      : super(_value, (v) => _then(v as NavigateToArchive));

  @override
  NavigateToArchive get _value => super._value as NavigateToArchive;

  @override
  $Res call({
    Object? key = freezed,
  }) {
    return _then(NavigateToArchive(
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as Key,
    ));
  }
}

/// @nodoc

class _$NavigateToArchive implements NavigateToArchive {
  const _$NavigateToArchive({required this.key});

  @override
  final Key key;

  @override
  String toString() {
    return 'ComicGalleryState.navigateToArchive(key: $key)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NavigateToArchive &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  $NavigateToArchiveCopyWith<NavigateToArchive> get copyWith =>
      _$NavigateToArchiveCopyWithImpl<NavigateToArchive>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)
        setButtonsVisibility,
    required TResult Function(Key key) navigateToArchive,
  }) {
    return navigateToArchive(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
  }) {
    return navigateToArchive?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Key key, bool previousButtonVisible, bool nextButtonVisible)?
        setButtonsVisibility,
    TResult Function(Key key)? navigateToArchive,
    required TResult orElse(),
  }) {
    if (navigateToArchive != null) {
      return navigateToArchive(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(SetButtonsVisibility value) setButtonsVisibility,
    required TResult Function(NavigateToArchive value) navigateToArchive,
  }) {
    return navigateToArchive(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
  }) {
    return navigateToArchive?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(SetButtonsVisibility value)? setButtonsVisibility,
    TResult Function(NavigateToArchive value)? navigateToArchive,
    required TResult orElse(),
  }) {
    if (navigateToArchive != null) {
      return navigateToArchive(this);
    }
    return orElse();
  }
}

abstract class NavigateToArchive implements ComicGalleryState {
  const factory NavigateToArchive({required Key key}) = _$NavigateToArchive;

  Key get key;
  @JsonKey(ignore: true)
  $NavigateToArchiveCopyWith<NavigateToArchive> get copyWith =>
      throw _privateConstructorUsedError;
}
